package org.jutil.event;


import java.util.EventObject;


/**
 * <p>This model type extends the Notifier contract, stating that only
 *   non-null events of type {@link eventType} are considered
 *   valid.</p>
 * <p>If your notifier only accepts non-null events of type
 *   {@link eventType} as valid events, you can simply model implement
 *   this type to inherit that contract. The implementation of
 *   {@link Notifier#notifyListner(EventListener, EventObject)} then can
 *   depend on the fact that it's event argument will be non-null and of
 *   type {@link eventType}, because this method is used as an
 *   abstract precondition.</p>
 These extra contracts only make sense if they introduce an implication
 if the form \result <== something (or a fortiori, an equivalence).
 We need to prove in the use of the actual notifyListener method,
 i.e., in the fireEvent method, that we adhere to the preconditions, i.e.,
 that this model methode returns true. An implication of the form
 \result ==> something leaves room for strengthening in subclasses,
 but we can only proof that the method returns false in some conditions.
 We cannot proof that the method will return true ever.
 * @path    $Source$
 * @version $Revision$
 * @date    $Date$
 * @state   $State$
 * @author  Jan Dockx
 * @release $Name$
 */
public interface EventTypeReliancy extends Notifier {

  public invariant eventType != null;
  public invariant Class.forName("java.util.EventObject").isAssignableFrom(eventType);

  public model instance Class eventType;

  /**
   * Asserts that <formal-arg>event</formal-arg> is of type
   * <formal-arg>eventType</formal-arg>. Subtypes cannot demand more.
   */
 /*@
   @ also public behavior
   @
   @ post \result <==> eventType.isInstance(event);
   @                        // false when event is null
   @*/
  public pure model boolean isValidEvent(EventObject event);
    // final because the contract states an equivalence
    // FIXME

}